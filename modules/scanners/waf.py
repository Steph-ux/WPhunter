"""
WPHunter - Professional WAF Detection
======================================
Multi-layer WAF and bot protection detection with stealth mode.

Features:
- 15+ WAF signatures (Cloudflare, Akamai, Imperva, F5, etc.)
- Bot protection detection (DataDome, PerimeterX, Kasada, etc.)
- DNS/Network layer detection
- Rate limiting detection
- Challenge detection (CAPTCHA, JS challenges)
- Stealth mode (subtle payloads, delays, UA rotation)
- DDoS protection detection

CWE-200: Information Exposure
"""

import asyncio
import re
import socket
import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set
from urllib.parse import urlparse

from core.http_client import WPHttpClient
from core.logger import logger


@dataclass
class WAFInfo:
    """WAF detection information."""
    detected: bool = False
    waf_name: Optional[str] = None
    confidence: str = "low"  # low, medium, high
    evidence: List[str] = field(default_factory=list)
    bypass_tips: List[str] = field(default_factory=list)
    tools: List[str] = field(default_factory=list)
    rate_limited: bool = False
    bot_protection: Optional[str] = None
    challenge_detected: Optional[str] = None
    
    def to_dict(self) -> Dict:
        return {
            "detected": self.detected,
            "waf_name": self.waf_name,
            "confidence": self.confidence,
            "evidence": self.evidence,
            "bypass_tips": self.bypass_tips[:5],
            "rate_limited": self.rate_limited,
            "bot_protection": self.bot_protection,
            "challenge": self.challenge_detected
        }


class WAFDetector:
    """
    Professional-grade WAF detection with stealth mode.
    
    Detection layers:
    1. DNS/Network (IP ranges, CNAME)
    2. Passive (headers, cookies, timing)
    3. Active (subtle payloads with delays)
    4. Challenge detection
    5. Rate limiting detection
    """
    
    # Comprehensive WAF signatures
    WAF_SIGNATURES = {
        "cloudflare": {
            "headers": ["cf-ray", "cf-cache-status", "cf-request-id", "cf-apo-via"],
            "cookies": ["__cfduid", "__cf_bm"],
            "server": ["cloudflare"],
            "body_patterns": [
                r"Attention Required.*Cloudflare",
                r"Ray ID: [a-f0-9]+",
                r"cloudflare-nginx"
            ],
            "status_codes": [403, 503, 520, 521, 522, 523, 524],
            "dns_indicators": ["cloudflare"],
            "bypass_tips": [
                "Find origin IP via: SecurityTrails, Censys, Shodan",
                "Check DNS history for origin IP leaks",
                "Scan IPv6 if available (often less protected)",
                "Test misconfigured subdomains bypassing CF",
                "Try HTTP/2 smuggling techniques",
                "Test websockets - often less filtered",
                "Use chunked encoding: Transfer-Encoding: chunked",
                "Check /cdn-cgi/trace endpoint for info",
                "Test OPTIONS method - sometimes bypasses rules"
            ],
            "tools": ["CloakQuest3r", "CloudFlair", "bypass-firewalls-by-DNS-history"]
        },
        
        "akamai": {
            "headers": [
                "akamai-grn", "akamai-origin-hop", "x-akamai-staging",
                "x-akamai-transformed", "x-check-cacheable"
            ],
            "cookies": ["AKA_A2", "ak_bmsc"],
            "server": [re.compile(r"AkamaiGHost")],
            "body_patterns": [
                r"Reference #[0-9a-f\.]+",
                r"Access Denied.*Akamai"
            ],
            "dns_indicators": ["akamaiedge.net", "edgekey.net"],
            "bypass_tips": [
                "Find origin via DNS enumeration",
                "Test with different geographic IPs",
                "Try cache poisoning via Host header",
                "Use Akamai's debug headers if exposed"
            ],
            "tools": ["Akamai-origin-finder"]
        },
        
        "wordfence": {
            "headers": ["x-wordfence-blocked"],
            "cookies": ["wfvt_", "wordfence_verifiedHuman"],
            "body_patterns": [
                r"Wordfence.*blocked",
                r"Generated by Wordfence at \d{4}-\d{2}-\d{2}",
                r"Wordfence\.com/help/general-data-protection-regulation"
            ],
            "bypass_tips": [
                "Try IP rotation (Wordfence blocks by IP)",
                "Use Tor or proxies",
                "Slow down requests (avoid rate limit)",
                "Try different User-Agents"
            ]
        },
        
        "sucuri": {
            "headers": ["x-sucuri-id", "x-sucuri-cache"],
            "cookies": ["sucuri-"],
            "server": ["Sucuri/Cloudproxy"],
            "body_patterns": [
                r"Access Denied.*Sucuri",
                r"Questions\?.*cloudproxy@sucuri\.net"
            ],
            "bypass_tips": [
                "Find origin IP (Sucuri is a proxy)",
                "Check for subdomain misconfigurations",
                "Test IPv6 if available"
            ]
        },
        
        "modsecurity": {
            "headers": ["mod_security"],
            "server": ["Mod_Security", "NOYB"],
            "body_patterns": [
                r"ModSecurity",
                r"Not Acceptable.*mod_security",
                r"406 Not Acceptable"
            ],
            "status_codes": [406, 501],
            "bypass_tips": [
                "Use encoding variations (URL, Unicode)",
                "Try case variations",
                "Use null bytes in payloads",
                "Test with chunked encoding"
            ]
        },
        
        "imperva": {
            "headers": ["x-cdn: imperva", "x-iinfo"],
            "cookies": ["_imp_apg_", "incap_ses_", "visid_incap_"],
            "body_patterns": [
                r"Incapsula incident ID",
                r"_Incapsula_Resource",
                r"Imperva"
            ],
            "bypass_tips": [
                "Find origin IP via DNS history",
                "Test with different User-Agents",
                "Try cache poisoning"
            ]
        },
        
        "aws_waf": {
            "headers": ["x-amzn-requestid", "x-amzn-trace-id", "x-amz-cf-id"],
            "server": ["awselb", "CloudFront"],
            "body_patterns": [r"Request blocked.*AWS"],
            "dns_indicators": ["cloudfront.net", "awsdns"],
            "bypass_tips": [
                "Find origin via S3 bucket enumeration",
                "Test different AWS regions",
                "Check for misconfigured CORS"
            ]
        },
        
        "f5_bigip": {
            "cookies": [re.compile(r"TS[a-f0-9]{6}"), "BIGipServer"],
            "headers": ["x-cnection: close"],  # Characteristic typo
            "server": ["BigIP", "F5"],
            "bypass_tips": [
                "Test with HTTP/1.0 (sometimes less filtered)",
                "Try different HTTP methods",
                "Use encoding variations"
            ]
        },
        
        "fortiweb": {
            "headers": ["fortiwafsid"],
            "cookies": ["FORTIWAFSID"],
            "server": ["FortiWeb"],
            "bypass_tips": [
                "Use encoding variations",
                "Try case manipulation",
                "Test with different protocols"
            ]
        },
        
        "barracuda": {
            "headers": ["barra_counter_session"],
            "cookies": ["barra_"],
            "server": ["Barracuda"],
            "body_patterns": [r"Barracuda"],
            "bypass_tips": [
                "Use obfuscation techniques",
                "Try different encodings",
                "Test with chunked transfer"
            ]
        },
        
        "citrix_netscaler": {
            "cookies": [re.compile(r"NSC_"), "citrix_ns_id"],
            "headers": ["via: NS-CACHE"],
            "server": ["NetScaler"],
            "bypass_tips": [
                "Test with different HTTP versions",
                "Try cache poisoning",
                "Use encoding variations"
            ]
        },
        
        "reblaze": {
            "cookies": ["rbzid"],
            "headers": ["x-cdn: reblaze"],
            "server": ["Reblaze"],
            "bypass_tips": [
                "Find origin IP",
                "Test with different geolocations"
            ]
        },
        
        "datapower": {
            "headers": ["x-backside-transport"],
            "cookies": ["dpjsessionid"],
            "server": ["IBM_HTTP_Server"],
            "bypass_tips": [
                "Test with different HTTP methods",
                "Use encoding variations"
            ]
        }
    }
    
    # Bot protection signatures
    BOT_PROTECTION = {
        "datadome": {
            "cookies": ["datadome"],
            "headers": ["x-datadome-cid"],
            "body_patterns": [r"datadome\.co"]
        },
        "perimeter_x": {
            "cookies": [re.compile(r"_px"), "_pxhd"],
            "body_patterns": [r"perimeter x", r"px-captcha", r"/_px/"]
        },
        "kasada": {
            "headers": ["x-kpsdk-ct", "x-kpsdk-cd"],
            "body_patterns": [r"kasada"]
        },
        "shape_security": {
            "headers": ["x-shape-sec"],
            "body_patterns": [r"/_guard/"]
        },
        "distil_networks": {
            "cookies": [re.compile(r"distil_"), "did"],
            "headers": ["x-distil-cs"]
        }
    }
    
    # Subtle trigger payloads (less likely to ban)
    SUBTLE_PAYLOADS = [
        "/?test=<svg/onload=alert(1)>",
        "/?id=1'||'1'='1",
        "/?page=....//....//etc/passwd",
        "/?cmd=$(whoami)",
        "/?x=%3Cscript%3E",
        "/?file=../etc/passwd",
    ]
    
    USER_AGENTS = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
    ]
    
    def __init__(self, http_client: WPHttpClient):
        self.http = http_client
        self.domain = urlparse(http_client.base_url).netloc
        
    @classmethod
    async def detect(cls, http_client: WPHttpClient, stealth: bool = True) -> WAFInfo:
        """
        Comprehensive WAF detection.
        
        Args:
            http_client: HTTP client
            stealth: Use stealth mode (recommended for bug bounty)
        """
        detector = cls(http_client)
        info = WAFInfo()
        
        # Layer 1: DNS/Network detection
        dns_waf = await detector._detect_via_dns()
        if dns_waf:
            info.detected = True
            info.waf_name = dns_waf
            info.confidence = "high"
            info.evidence.append(f"DNS indicates {dns_waf}")
        
        # Layer 2: Passive detection
        passive_waf = await detector._passive_detect()
        if passive_waf:
            info.detected = True
            if not info.waf_name:
                info.waf_name = passive_waf["name"]
                info.confidence = passive_waf["confidence"]
            info.evidence.extend(passive_waf["evidence"])
        
        # Layer 3: Rate limiting detection
        rate_limit_info = await detector._detect_rate_limiting()
        if rate_limit_info["limited"]:
            info.rate_limited = True
            info.evidence.append(f"Rate limiting: {rate_limit_info.get('type', 'unknown')}")
        
        # Layer 4: Bot protection detection
        bot_protection = await detector._detect_bot_protection()
        if bot_protection:
            info.bot_protection = bot_protection
            info.evidence.append(f"Bot protection: {bot_protection}")
        
        # Layer 5: Active detection (only if stealth=False or no detection yet)
        if not stealth and not info.detected:
            active_waf = await detector._active_detect()
            if active_waf:
                info.detected = True
                info.waf_name = active_waf["name"]
                info.confidence = "medium"
                info.evidence.extend(active_waf["evidence"])
        
        # Add bypass tips if WAF detected
        if info.waf_name and info.waf_name in cls.WAF_SIGNATURES:
            sig = cls.WAF_SIGNATURES[info.waf_name]
            info.bypass_tips = sig.get("bypass_tips", [])
            info.tools = sig.get("tools", [])
        
        return info
    
    async def _detect_via_dns(self) -> Optional[str]:
        """Detect WAF via DNS/IP analysis."""
        try:
            # Get IP address
            ip = socket.gethostbyname(self.domain)
            
            # Check Cloudflare IP ranges
            if self._is_cloudflare_ip(ip):
                return "cloudflare"
            
            # Check CNAME records (requires dnspython, skip if not available)
            try:
                import dns.resolver
                answers = dns.resolver.resolve(self.domain, 'CNAME')
                for rdata in answers:
                    cname = str(rdata.target).lower()
                    
                    if "akamaiedge.net" in cname or "edgekey.net" in cname:
                        return "akamai"
                    elif "cloudfront.net" in cname:
                        return "aws_waf"
                    elif "cloudflare" in cname:
                        return "cloudflare"
                    elif "incapdns.net" in cname:
                        return "imperva"
                        
            except ImportError:
                pass  # dnspython not available
            except Exception:
                pass
                
        except Exception as e:
            logger.debug(f"DNS detection failed: {e}")
        
        return None
    
    def _is_cloudflare_ip(self, ip: str) -> bool:
        """Check if IP is in Cloudflare ranges."""
        # Cloudflare IPv4 ranges (simplified)
        cf_ranges = [
            "173.245.48.0/20", "103.21.244.0/22", "103.22.200.0/22",
            "103.31.4.0/22", "141.101.64.0/18", "108.162.192.0/18",
            "190.93.240.0/20", "188.114.96.0/20", "197.234.240.0/22",
            "198.41.128.0/17", "162.158.0.0/15", "104.16.0.0/13",
            "104.24.0.0/14", "172.64.0.0/13", "131.0.72.0/22"
        ]
        
        # Simple check (would need ipaddress module for proper CIDR matching)
        ip_parts = ip.split('.')
        if len(ip_parts) == 4:
            first_octet = int(ip_parts[0])
            second_octet = int(ip_parts[1])
            
            # Quick heuristic check
            if first_octet in [173, 103, 141, 108, 190, 188, 197, 198, 162, 104, 172, 131]:
                return True
        
        return False
    
    async def _passive_detect(self) -> Optional[Dict]:
        """Passive WAF detection via headers/cookies."""
        try:
            response = await self.http.get("/", timeout=10)
            
            for waf_name, signatures in self.WAF_SIGNATURES.items():
                evidence = []
                matches = 0
                
                # Check headers
                for header_sig in signatures.get("headers", []):
                    for header, value in response.headers.items():
                        if isinstance(header_sig, re.Pattern):
                            if header_sig.search(header.lower()) or header_sig.search(str(value).lower()):
                                evidence.append(f"Header: {header}")
                                matches += 1
                        elif header_sig.lower() in header.lower() or header_sig.lower() in str(value).lower():
                            evidence.append(f"Header: {header}")
                            matches += 1
                
                # Check cookies
                for cookie_sig in signatures.get("cookies", []):
                    for cookie in response.cookies:
                        if isinstance(cookie_sig, re.Pattern):
                            if cookie_sig.search(cookie.name):
                                evidence.append(f"Cookie: {cookie.name}")
                                matches += 1
                        elif cookie_sig in cookie.name:
                            evidence.append(f"Cookie: {cookie.name}")
                            matches += 1
                
                # Check server header
                server = response.headers.get("server", "").lower()
                for server_sig in signatures.get("server", []):
                    if isinstance(server_sig, re.Pattern):
                        if server_sig.search(server):
                            evidence.append(f"Server: {server}")
                            matches += 2
                    elif server_sig.lower() in server:
                        evidence.append(f"Server: {server}")
                        matches += 2
                
                # Check body patterns
                for pattern in signatures.get("body_patterns", []):
                    if re.search(pattern, response.text, re.IGNORECASE):
                        evidence.append(f"Body pattern: {pattern[:50]}")
                        matches += 1
                
                # Determine confidence
                if matches >= 3:
                    return {"name": waf_name, "evidence": evidence, "confidence": "high"}
                elif matches >= 2:
                    return {"name": waf_name, "evidence": evidence, "confidence": "medium"}
                elif matches >= 1:
                    return {"name": waf_name, "evidence": evidence, "confidence": "low"}
                    
        except Exception as e:
            logger.debug(f"Passive detection failed: {e}")
        
        return None
    
    async def _detect_rate_limiting(self) -> Dict:
        """Detect rate limiting before full scan."""
        logger.debug("Testing for rate limiting...")
        
        start = time.time()
        responses = []
        
        # Send 15 quick requests
        for i in range(15):
            try:
                r = await self.http.get(f"/?test={i}", timeout=5)
                responses.append({
                    "status": r.status_code,
                    "time": time.time() - start,
                    "size": len(r.text)
                })
            except Exception:
                pass
            
            await asyncio.sleep(0.1)  # Small delay
        
        # Analyze patterns
        status_429 = sum(1 for r in responses if r["status"] == 429)
        if status_429 > 3:
            return {"limited": True, "type": "429_responses", "threshold": len(responses) - status_429}
        
        # Check for throttling (increasing response times)
        if len(responses) >= 10:
            times = [r["time"] for r in responses]
            if times[-1] > times[0] * 3:
                return {"limited": True, "type": "throttling"}
        
        # Check for size reduction (some WAFs return smaller responses)
        if len(responses) >= 10:
            sizes = [r["size"] for r in responses]
            if sizes[-1] < sizes[0] * 0.5:
                return {"limited": True, "type": "response_reduction"}
        
        return {"limited": False}
    
    async def _detect_bot_protection(self) -> Optional[str]:
        """Detect bot protection systems."""
        try:
            response = await self.http.get("/", timeout=10)
            
            # Check for challenges
            challenge = self._detect_challenge(response)
            if challenge:
                return challenge
            
            # Check bot protection signatures
            for bot_name, signatures in self.BOT_PROTECTION.items():
                matches = 0
                
                for cookie_sig in signatures.get("cookies", []):
                    for cookie in response.cookies:
                        if isinstance(cookie_sig, re.Pattern):
                            if cookie_sig.search(cookie.name):
                                matches += 1
                        elif cookie_sig in cookie.name:
                            matches += 1
                
                for header_sig in signatures.get("headers", []):
                    if header_sig.lower() in [h.lower() for h in response.headers.keys()]:
                        matches += 1
                
                for pattern in signatures.get("body_patterns", []):
                    if re.search(pattern, response.text, re.IGNORECASE):
                        matches += 1
                
                if matches >= 1:
                    return bot_name
                    
        except Exception as e:
            logger.debug(f"Bot protection detection failed: {e}")
        
        return None
    
    def _detect_challenge(self, response) -> Optional[str]:
        """Detect CAPTCHA/JS challenges."""
        challenges = {
            "recaptcha": "google.com/recaptcha",
            "hcaptcha": "hcaptcha.com",
            "cloudflare_js": "__cf_chl_jschl_tk__",
            "cloudflare_captcha": "cf-challenge-running",
            "cloudflare_turnstile": "challenges.cloudflare.com",
            "datadome": "datadome.co/captcha",
            "perimeter_x": "/_px/captcha",
            "funcaptcha": "funcaptcha.com"
        }
        
        for challenge_name, signature in challenges.items():
            if signature in response.text:
                return challenge_name
        
        return None
    
    async def _active_detect(self) -> Optional[Dict]:
        """Active detection with subtle payloads and delays."""
        logger.debug("Active WAF detection (stealth mode)...")
        
        for i, payload in enumerate(self.SUBTLE_PAYLOADS[:3]):
            # Progressive delay
            if i > 0:
                await asyncio.sleep(2 ** i)
            
            # Rotate User-Agent
            headers = {"User-Agent": self.USER_AGENTS[i % len(self.USER_AGENTS)]}
            
            try:
                response = await self.http.get(payload, headers=headers, timeout=10)
                
                # Check if banned
                if self._is_banned(response):
                    logger.warning("Possible ban detected during active scan")
                    break
                
                # Check for WAF block
                for waf_name, signatures in self.WAF_SIGNATURES.items():
                    if response.status_code in signatures.get("status_codes", []):
                        for pattern in signatures.get("body_patterns", []):
                            if re.search(pattern, response.text, re.IGNORECASE):
                                return {
                                    "name": waf_name,
                                    "evidence": [f"Blocked with status {response.status_code}", f"Pattern: {pattern[:50]}"]
                                }
                                
            except Exception as e:
                logger.debug(f"Active detection request failed: {e}")
                continue
        
        return None
    
    def _is_banned(self, response) -> bool:
        """Check if we've been banned."""
        ban_indicators = [
            response.status_code in [403, 429, 503],
            "banned" in response.text.lower(),
            "blocked" in response.text.lower(),
            len(response.text) < 100  # Suspiciously small response
        ]
        
        return sum(ban_indicators) >= 2
